generator client {
  provider = "prisma-client-js"
  output   = "../lib/generated/prisma"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

model brand {
  id        String    @id
  name      String
  isActive  Boolean   @default(true)
  createdAt DateTime  @default(now())
  createdBy String?
  updatedAt DateTime?
  updatedBy String?
  product   product[]
}

model category {
  id        String    @id
  name      String
  createdAt DateTime  @default(now())
  createdBy String?
  updatedAt DateTime?
  updatedBy String?
  isActive  Boolean   @default(true)
  product   product[]
}

model product {
  id                String            @id
  code              String            @unique(map: "Product_code_key")
  name              String
  price             Float             @default(0)
  stock             Int               @default(0)
  unit              String
  isActive          Boolean           @default(true)
  storageLocationId String
  supplierId        String?
  productCategoryId String
  condition         product_condition @default(New)
  restockDate       DateTime          @default(now())
  imageUrl          String?
  barcode           String?
  createdAt         DateTime          @default(now())
  createdBy         String?
  updatedAt         DateTime?
  updatedBy         String?
  brandId           String?
  inbound           inbound[]
  outbound          outbound[]
  brand             brand?            @relation(fields: [brandId], references: [id], map: "Product_brandId_fkey")
  category          category          @relation(fields: [productCategoryId], references: [id], map: "Product_productCategoryId_fkey")
  storagelocation   storagelocation   @relation(fields: [storageLocationId], references: [id], map: "Product_storageLocationId_fkey")
  supplier          supplier?         @relation(fields: [supplierId], references: [id], map: "Product_supplierId_fkey")
  stockadjustment   stockadjustment[]

  @@index([brandId], map: "Product_brandId_fkey")
  @@index([productCategoryId], map: "Product_productCategoryId_fkey")
  @@index([storageLocationId], map: "Product_storageLocationId_fkey")
  @@index([supplierId], map: "Product_supplierId_fkey")
}

model stockadjustment {
  id         String   @id
  productId  String
  oldQty     Int
  newQty     Int
  type       String
  difference Int
  reason     String
  note       String   @db.VarChar(255)
  createdBy  String
  createdAt  DateTime @default(now())
  product    product  @relation(fields: [productId], references: [id], onDelete: Cascade, map: "StockAdjustment_productId_fkey")

  @@index([productId], map: "StockAdjustment_productId_fkey")
}

model storagelocation {
  id              String                @id
  code            String                @unique(map: "StorageLocation_code_key")
  name            String
  description     String?
  type            storagelocation_type?
  zone            String?
  maxCapacity     Int?
  currentCapacity Int?
  capacityUnit    String?
  isActive        Boolean               @default(true)
  createdAt       DateTime              @default(now())
  createdBy       String?
  updatedAt       DateTime?
  updatedBy       String?
  product         product[]
}

model supplier {
  id        String    @id
  name      String
  isActive  Boolean   @default(true)
  createdAt DateTime  @default(now())
  createdBy String?
  updatedAt DateTime?
  updatedBy String?
  inbound   inbound[]
  product   product[]
}

model user {
  id        String    @id
  email     String    @unique(map: "User_email_key")
  username  String
  password  String
  createdAt DateTime  @default(now())
  createdBy String?
  updatedAt DateTime?
  updatedBy String?
}

model inbound {
  id               String          @id
  productId        String
  supplierId       String?
  qty              Int
  purchasePrice    Decimal         @db.Decimal(15, 2)
  totalPrice       Decimal?        @default(0.00) @db.Decimal(15, 2)
  status           inbound_status? @default(RECEIVED)
  receiveDate      DateTime?       @default(now()) @db.DateTime(0)
  itemCheckingDate DateTime?       @db.DateTime(0)
  storedDate       DateTime?       @db.DateTime(0)
  canceledDate     DateTime?       @db.DateTime(0)
  canceledNote     String?         @db.VarChar(255)
  note             String?         @db.VarChar(255)
  createdAt        DateTime?       @default(now()) @db.DateTime(0)
  createdBy        String?         @db.VarChar(100)
  updatedAt        DateTime?       @db.DateTime(0)
  updatedBy        String?         @db.VarChar(100)
  product          product         @relation(fields: [productId], references: [id], onDelete: Cascade, onUpdate: Restrict, map: "fk_inbound_product")
  supplier         supplier?       @relation(fields: [supplierId], references: [id], onUpdate: Restrict, map: "fk_inbound_supplier")

  @@index([productId], map: "fk_inbound_product")
  @@index([supplierId], map: "fk_inbound_supplier")
}

model outbound {
  id              Int             @id @default(autoincrement())
  productId       String
  qty             Int
  sellingPrice    Decimal         @db.Decimal(18, 2)
  operationalCost Decimal         @db.Decimal(18, 2)
  status          outbound_status @default(SENT)
  note            String?         @db.VarChar(255)
  createdBy       String?         @db.VarChar(100)
  createdAt       DateTime?       @default(now()) @db.DateTime(0)
  isShipping      Boolean         @default(false)
  shippingDate    DateTime?       @db.Date
  courier         String?         @db.VarChar(100)
  isResi          Boolean?        @default(false)
  resiImg         String?         @db.VarChar(255)
  resiUploadDate  DateTime?       @db.DateTime(0)
  isPickup        Boolean         @default(false)
  pickupDate      DateTime?       @db.Date
  updateBy        String?         @db.VarChar(255)
  updatedAt       DateTime?       @db.Timestamp(0)
  pickupBy        String?         @db.VarChar(100)
  product         product         @relation(fields: [productId], references: [id], map: "fk_product")

  @@index([productId], map: "fk_product")
}

enum storagelocation_type {
  rack
  shelf
  drawer
  box
  cabinet
  bin
}

enum product_condition {
  New
  Used
  Refurbished
}

enum inbound_status {
  RECEIVED
  CHECKING
  STORED
  CANCELED
}

enum outbound_status {
  SENT
  PROCESSING
  DELIVERED
  CANCELED
  SHIPPED
  PICKED_UP  @map("PICKED UP")
}
